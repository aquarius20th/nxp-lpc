/****************************************Copyright (c)**************************************************
**                                        
**                                      
**                                      
**
**                           
**
**--------------文件信息--------------------------------------------------------------------------------
**文   件   名:  
**创   建   人:  
**最后修改日期: 
**描        述:   软件定时器,软时钟的处理，系统时间处理
**备        注 :  定时器的回调可以有两种执行方法，一种是在毫秒中断里面直接执行，另外一种以队列存储，然后
                  在任务里面执行，各有优缺点，本模块采用后者实现
**--------------历史版本信息----------------------------------------------------------------------------
** 创建人:  
** 版  本:  
** 日　期:  
** 描　述: 
**
**--------------当前版本修订------------------------------------------------------------------------------
** 修改人:
** 日　期:
** 描　述:  
**
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#include <stdlib.h> 
#include "TimerExt.h"

static EXT_TIMER  g_Timer[EXT_TIMER_CNT];

 
/*********************************************************************************************************
** 函数名称: InitTimerMgr
** 函数名称: InitTimerMgr
**
** 功能描述： 
**
**          
** 输　出:  void
**         
** 全局变量:  
** 调用模块: 无
**
** 作　者:  LiJin
** 日　期:  2008年9月17日
** 备  注: 
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
** 备  注: 
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void InitTimerMgr(void )
{
#if  EXT_TIMER_CB_EN > 0
	INT8U err = 0;
#endif
	INT8U i = 0;

	for ( i = 0; i < EXT_TIMER_CNT; i++)
	{
		g_Timer[i].Enable = RT_FALSE;
		g_Timer[i].Count = 0;
		g_Timer[i].TimeOut = 0;
		g_Timer[i].Flag = RT_FALSE;
 
	}
 
}
/*********************************************************************************************************
** 函数名称: TimerMgrInMsInt
** 函数名称: TimerMgrInMsInt
**
** 功能描述： 在毫秒中断里面调用
**
**          
** 输　出:  void
**         
** 全局变量:  
** 调用模块: 无
**
** 作　者:  LiJin
** 日　期:  2008年9月17日
** 备  注:  这里面存在一个资源冲突的情况，不过无所谓的。
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
** 备  注: ISR 里面已经做了保护了
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void ExtTimerTick(  )
{
	INT16U  i = 0;
#if  EXT_TIMER_CB_EN > 0
	TIMER_MSG *pTimerMsg = NULL;
	INT8U err = 0;
#endif

#ifdef EXT_TMR_CFG_TICKS_PER_SEC
	INT16U nCnt = EXT_TMR_CFG_TICKS_PER_SEC;
#else
	INT16U nCnt = 1000/OS_TICKS_PER_SEC;
#endif // _DEBUG
	if(nCnt == 0)
   		nCnt = 10;

//	OS_ENTER_CRITICAL();	
	for ( i = 0; i < EXT_TIMER_CNT; i++)
	{
		if (g_Timer[i].Enable && g_Timer[i].TimeOut  )
		{
			g_Timer[i].Count += nCnt; //10毫秒一个TICK
			if (g_Timer[i].Count >= g_Timer[i].TimeOut )
			{
				g_Timer[i].Flag = RT_TRUE;
				g_Timer[i].Count = 0;
 
			}
		}	
	}
//	OS_EXIT_CRITICAL();
}
 
/*********************************************************************************************************
** 函数名称: SetTimer
** 函数名称: SetTimer
**
** 功能描述： 安装一个定时器
**
** 输　入:  INT16U TimerID
** 输　入:  INT32U nTime
** 输　入:  fnTimerProcess fnProc 定时器的回调函数
** 输　入:  void * pFuncParam     回调函数的参数
**          
** 输　出:  INT16U
**         
** 全局变量:  
** 调用模块: 无
**
** 作　者:  LiJin
** 日　期:  2008年9月18日
** 备  注: 
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
** 备  注: 
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
INT16U  SetTimer(INT16U TimerID, INT32U nTime )
{
                              
	OS_CPU_SR  cpu_sr;
 
	INT16U i = 0;

	if (TimerID>0 && TimerID <= EXT_TIMER_CNT && nTime)
	{
		OS_ENTER_CRITICAL();	

		g_Timer[TimerID-1].Enable = RT_TRUE;
		g_Timer[TimerID-1].TimeOut = nTime;
		g_Timer[TimerID-1].Count = 0;
 
		OS_EXIT_CRITICAL();
		return TimerID;
	}
	else if ( TimerID == 0 && nTime )
	{
		OS_ENTER_CRITICAL();	
		for ( i = 0; i < EXT_TIMER_CNT ; i++)
		{
			if (g_Timer[i].Enable == RT_FALSE)
			{
				g_Timer[i].Enable = RT_TRUE;
				g_Timer[i].TimeOut = nTime;
				g_Timer[i].Count = 0;
 
				OS_EXIT_CRITICAL();
				return i+1;
			}
		}
	}
	return RT_FALSE;
}

/*********************************************************************************************************
** 函数名称: KillTimer
** 函数名称: KillTimer
**
** 功能描述： 删除定时器
**
** 输　入:  INT16U TimerID
**          
** 输　出:  INT8U
**         
** 全局变量:  
** 调用模块: 无
**
** 作　者:  LiJin
** 日　期:  2008年9月18日
** 备  注: 
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
** 备  注: 
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
INT8U   KillTimer (INT32U  TimerID)
{
                               
	OS_CPU_SR  cpu_sr;
 
	if (TimerID>0 && TimerID <= EXT_TIMER_CNT )
	{		
		g_Timer[TimerID-1].TimeOut = 0;
		g_Timer[TimerID-1].Count = 0;
		g_Timer[TimerID-1].Flag = RT_FALSE;
		if (g_Timer[TimerID-1].Enable)
		{
			OS_ENTER_CRITICAL();	
			g_Timer[TimerID-1].Enable = RT_FALSE;
#if  EXT_TIMER_CB_EN > 0
			g_Timer[TimerID-1].pFunc = NULL; //可能会有问题 
			g_Timer[TimerID-1].pFuncParam = NULL;
#endif
			OS_EXIT_CRITICAL();
			return RT_TRUE;
		}		
	}
	return RT_FALSE;
}

/*********************************************************************************************************
** 函数名称: ResetTimer
** 函数名称: ResetTimer
**
** 功能描述： 定时重新计时
**
** 输　入:  INT16U TimerID
**          
** 输　出:  INT8U
**         
** 全局变量:  
** 调用模块: 无
**
** 作　者:  LiJin
** 日　期:  2008年9月18日
** 备  注: 
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
** 备  注: 
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
INT8U  ResetTimer(INT32U TimerID)
{
	if (TimerID>0 && TimerID <= EXT_TIMER_CNT )
	{
		if (g_Timer[TimerID-1].Enable)
		{
		 	g_Timer[TimerID-1].Count = 0;
			return RT_TRUE;
		}		
	}
	return RT_FALSE;
}

/*********************************************************************************************************
** 函数名称: IsTimeTo
** 函数名称: IsTimeTo
**
** 功能描述： 判断定时是否到。
**
** 输　入:  INT16U TimerID
**          
** 输　出:  INT8U
**         
** 全局变量:  
** 调用模块: 无
**
** 作　者:  LiJin
** 日　期:  2008年9月17日
** 备  注:  此接口被调用后，定时到标志就被翻转了
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
** 备  注: 
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
INT8U IsTimeTo(INT32U TimerID )
{
	if (TimerID>0 && TimerID <= EXT_TIMER_CNT)
	{
		if (g_Timer[TimerID-1].Enable && g_Timer[TimerID-1].Flag == RT_TRUE)
		{
			g_Timer[TimerID-1].Flag = RT_FALSE;
			return RT_TRUE;
		}
	}
	return RT_FALSE;
}

/*
//测试用的定时器回调函数
void TimerTestFunc( void * pPara )
{
	INT16U *pCnt =  pPara ;

	INT16U aa = *pCnt;

	aa++;

}

void TestTimer( )
{
	INT16U cnt = 0;
	INT8U bRet = RT_FALSE;
	INT32U nTest = 0;

	SetTimer(1,100,TimerTestFunc,&cnt);
	SetTimer(2,1000,NULL,NULL);

	while (1)
	{
		OSTimeDly(2);
		bRet = IsTimeTo(2);
		if (bRet)
		{
			 nTest ++;
		}
	}
}*/
